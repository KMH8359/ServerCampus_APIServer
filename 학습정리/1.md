# HTTP
* 웹 서버와 클라이언트 간의 통신을 정의하는 프로토콜(규칙)
* 요청(request)과 응답(response)의 반복으로 통신이 진행됨
* GET, PUT, POST, DELETE 등 고정된 메서드를 통해 통신함
* 연결을 유지하지 않는 비연결형(stateless) 프로토콜
 - 한 번 request-response 통신을 진행한 후 바로 연결을 종료한다.
 - 현재의 통신은 과거에 있었던 통신의 정보를 알지 못함
 - 이런 문제를 해결하기 위해 로그인 토큰, 브라우저 쿠키 등을 통해 휘발적인 정보를 저장한다.

## HTTPS
* HTTP에 암호화를 적용하여 보다 신뢰성 높은 통신을 제공하는 프로토콜
### 암호화의 종류
#### 대칭 키 암호화
* 하나의 공개 키를 사용하여 암호화와 복호화를 진행함
* 비대칭 키 암호화에 비해 빠른 속도를 갖고 있으나 공개 키가 탈취당하면 데이터가 바로 위험에 노출됨
#### 비대칭 키 암호화
* 공개 키에 더해 개인 키를 사용하여 암호화/복호화
* 두 개의 키를 사용하여 보다 안전하지만 추가 작업이 발생하여 대칭 키 암호화에 비해 속도가 느림
- 각자 장단점이 있기 때문에 필요에 따라 선택하여 사용한다.
- HTTPS는 대칭 키 암호화와 비대칭 키 암호화를 함께 사용하여 보다 수준 높은 암호화를 제공한다.

## HTTP 통신 함수 
### GET
* 데이터를 서버로부터 받아오기 위해 주로 사용되는 메서드
* 쿼리의 헤드에 읽고자 하는 데이터의 정보가 포함되어 있음 - 보안이 취약하다. 또한 URL 길이에 제한이 있으므로 쿼리의 길이도 똑같이 제약을 받음
* 그러나 URL에 데이터가 저장되기 때문에 POST와 다르게 한 번 요청하면 레지스터에 정보를 저장하는 캐싱 기능을 사용할 수 있기 때문에 중요도가 낮은 정보는 GET을 쓰는 것이 속도 면에서 효율적이다.
``` 쿼리 예시
    'https://example.com/api/data?name=John&age=30'
```
### POST
* 데이터를 생성할 때 주로 사용되는 메서드(그러나 데이터를 JSON으로 전달하거나 보안상 중요한 정보를 다룰 경우 데이터를 받아오는 목적으로도 사용된다.)
* 쿼리가 아닌 내부 body에 읽고자 하는 데이터의 정보를 포함
* 쿼리에 데이터가 나타나지 않기 때문에 GET에 비해  보안적으로 조금 더 우월함. 그러나 여전히 해킹의 가능성은 존재하므로 주의
* URL에 데이터가 저장되지 않으므로 캐싱은 불가능함   
``` 쿼리 예시
    'https://example.com/api/'
    {
        "name": "John",
        "age": 30
    }
```
### PUT
* 데이터를 수정할 때 주로 사용되는 메서드
* body에 수정할 데이터를 담아 전송함
* 기존 데이터를 body로 받은 데이터로 교체(덮어씌움)
### PATCH 
* 데이터를 수정할 때 사용되는 것은 PUT과 동일하지만 PUT과 달리 기존 데이터 중 일부만을 수정함
### DELETE
* 데이터 제거 메서드

# JSON
* JAVASCRIPT 문법으로 구조화된 문자 기반 데이터 포맷
* 웹 서버 통신에 주로 사용됨
## 데이터 형식
``` example
{
  "employees": [
    {
      "name": "Surim",
      "lastName": "Son"
    },
    {
      "name": "Someone",
      "lastName": "Huh"
    },
    {
      "name": "Someone else",
      "lastName": "Kim"
    } 
  ]
}
```
* key와 value의 쌍으로 구성됨
* value가 내부에서 또다른 value를 갖는 key값으로 사용될 수 있다.
* key나 문자열은 항상 쌍따옴표 ""로 감싸 표기해야한다.

## 장단점
### 장점
* 이해하기 쉽고 용량이 작음
* 언어에 종속적이지 않음
### 단점
* 스키마를 사용하여 데이터 검증이 가능한 XML과 달리 검증이 불가능함
* 주석 사용이 불가능



# Stateless 서버와 Stateful 서버의 비교                                                          
## Stateless 서버
* 클라이언트의 상태를 유지하지 않고, 이후의 요청이 이전 요청과 서로 독립적임
* 상태를 유지하지 않기 때문에 복잡성이 낮으며, 서버 간의 부하 분산이 쉬워 수평 확장이 용이함
* 클라이언트의 상태를 유지하지 않기 때문에 매 요청마다 클라이언트에게 새로운 정보를 받아야 함
## Stateful 서버
* 클라이언트의 상태를 유지하고, 이전 요청의 상태를 활용하여 이후의 요청을 처리함
* 실시간으로 통신이 진행되는 구조에서 빠르게 데이터를 처리할 수 있음
* 상태를 유지하기 때문에 구조가 복잡해지고, 서버 간의 부하 분산이 어려워 수평 확장이 어려움